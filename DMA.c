#include <stdio.h>
#include <stdlib.h>

int main() {
    int* dynamicArray = (int*)malloc(5 * sizeof(int));

    if (dynamicArray == NULL) {
        printf("Memory allocation failed.\n");
        return 1;                                               // Exit with an error code
    }

// Use the dynamically allocated array...

    free(dynamicArray);                                         // Release the allocated memory

    return 0;                                                   // Exit successfully
}



    /*
    Dynamic Memory Allocation is a way to allocate memory to a data structure during the runtime
    we need some functions to allocate and free memory dynamically

    Dynamic memory allocation in the C programming language is performed using functions from the stdlib.h library, 
    namely malloc, calloc, realloc, and free. These functions allow us to allocate and deallocate memory during the 
    execution of a program. Here's a brief overview of each function:

    malloc (Memory Allocation):
    Syntax: void* malloc(size_t size);
    Allocates a block of memory of the specified size (in bytes).
    Returns a pointer to the beginning of the allocated memory.

    calloc (Contiguous Allocation):
    Syntax: void* calloc(size_t num_elements, size_t element_size);
    Allocates a block of memory for an array of elements, each with a size of element_size.
    Initializes the allocated memory to zero.
    Returns a pointer to the beginning of the allocated memory.   

    realloc (Reallocate Memory):
    Syntax: void* realloc(void* ptr, size_t new_size);
    Changes the size of the previously allocated block of memory pointed to by ptr to the new size.
    Returns a pointer to the beginning of the reallocated memory.

    free (Free Memory):
    Syntax: void free(void* ptr);
    Deallocates the memory block pointed to by ptr, making it available for further use.


    It's important to note the following points when working with dynamic memory in C:
    Always check if memory allocation is successful (if the returned pointer is not NULL).
    Free allocated memory using the free function to avoid memory leaks.
    Be cautious about accessing memory beyond the allocated size to prevent undefined behavior
    */



/*
In C programming, "compile time" and "run time" refer to different phases of the software development and execution process:

Compile Time:

Definition: Compile time refers to the period during which a program is being translated from its source code 
(written in a high-level language like C) into machine code or an intermediate code by a compiler.
Activities: During compile time, the compiler performs syntax checking, semantic analysis, optimization, and generates an executable file.
Errors: Compile-time errors are those that occur during the compilation process when the code violates language rules. 
Examples include syntax errors and type mismatch errors.
Output: The output of the compilation process is typically an executable file 
(e.g., an executable binary or an intermediate code) that can be run later.

Run Time:

Definition: Run time, also known as execution time, is the period when a compiled program is executed by the computer's CPU. 
It starts when the user runs the program and continues until the program terminates.
Activities: During run time, the CPU executes the machine code generated by the compiler, and the program performs its intended tasks.
Errors: Run-time errors are those that occur while the program is running. 
Examples include division by zero, accessing invalid memory, or attempting to open a non-existent file.
Output: The output during run time is the result of the program's execution, which may include 
data processing, user interactions, or other operations.

In summary, compile time is the phase when the source code is translated into machine code by the compiler, 
and run time is the period when the compiled program is executed, performing its specified tasks. 
Compile-time errors are detected by the compiler, while run-time errors occur during the execution of the program.
*/


/*
Static memory allocation in C refers to the allocation of memory at compile-time, where the 
memory size and type are known before the program is executed. 
*/


/*
our C program dynamically allocates an array of integers, checks if the memory allocation was 
successful, and then proceeds to use the dynamically allocated array before freeing the memory. 
Here's a breakdown of our code:

#include <stdio.h>: This line includes the standard input-output header file.

#include <stdlib.h>: This line includes the standard library header file, which provides functions like malloc and free.

int main() {: This line marks the beginning of the main function.

int* dynamicArray = (int*)malloc(5 * sizeof(int));: Allocates memory for an array of 5 integers using malloc. 
The sizeof(int) is used to determine the size of each integer in bytes. The cast (int*) is used to 
convert the void pointer returned by malloc to an integer pointer.

if (dynamicArray == NULL) {: Checks if the memory allocation was successful by verifying if dynamicArray is NULL. 
If allocation fails, an error message is printed, and the program exits with an error code.

// Use the dynamically allocated array...: This is a comment indicating that this is where you would 
perform operations with the dynamically allocated array.

free(dynamicArray);: Releases the dynamically allocated memory using the free function.

return 0;: Indicates the successful execution of the program.

return 1;: If memory allocation fails, the program exits with an error code to indicate the failure.

This program serves as a template for dynamic memory allocation and includes a check for the success of the allocation. 
It's good practice to check for the success of memory allocation, especially when working with dynamic memory. 
Also, remember to perform any necessary operations with the allocated memory before releasing it using free.

The provided code is an example template, and it doesn't contain specific output statements. 
*/